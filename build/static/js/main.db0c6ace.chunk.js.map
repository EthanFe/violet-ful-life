{"version":3,"sources":["MessageAuthorEnum.js","components/MessagesWindow.js","components/MessageContainer.js","components/TitleBar.js","components/Wrapper.js","App.js","serviceWorker.js","index.js"],"names":["SENT","MessagesWindow","conversation","className","map","index","message","sender","key","toLowerCase","indexOf","containerStyle","width","border","borderRadius","textAlign","padding","backgroundColor","styles","base","transitionProperty","transitionDuration","position","top","transform","opacity","exitAnimation","entryAnimation","flexContainer","display","justifyContent","alignItems","height","MessageContainer","content","exiting","useState","animatorStyles","setStyles","useEffect","setTimeout","style","titleBarContainer","fontSize","marginTop","color","titleBar","background","boxShadow","zIndex","TitleBar","wrapper","previousContent","conversationKey","Wrapper","contentChanged","pickRandom","array","Math","floor","random","length","conversations","require","seenConversations","initialConversation","Object","keys","timeout","App","conversationIndex","setConversation","cycleMessage","unseenConversations","filter","nextConversation","onClick","clearTimeout","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.db0c6ace.chunk.js","sourcesContent":["const SENT = 0\nconst RECEIVED = 1;\n\nexport { SENT, RECEIVED }","import React from 'react';\nimport \"./messages.css\"\nimport { SENT } from '../MessageAuthorEnum';\n\nfunction MessagesWindow({conversation}) {\n  return (\n    <div className=\"messages-container\">\n      {\n        conversation.map(([message, sender], index) => \n          <p key={index} className={`messages-p from-${sender === SENT ? \"me\" : \"them\"} ${message.toLowerCase().indexOf(\"omfg\") === -1 ? \"faded\" : \"\"}`}>{message}</p>\n        )\n      }\n    </div>\n    \n  );\n}\n\nexport default MessagesWindow;","import React, { useEffect, useState } from 'react';\nimport MessagesWindow from './MessagesWindow';\n\nconst containerStyle = {\n  width: \"500px\",\n  border: \"2px solid #00000040\",\n  borderRadius: \"5%\",\n  textAlign: \"center\",\n  padding: \"0px 5px\",\n  backgroundColor: \"white\"\n}\n\n\nconst styles = {\n  base: {\n    transitionProperty: \"transform, opacity, top\",\n    transitionDuration: \"1000ms\",\n    position: \"relative\",\n    top: \"150%\",\n    transform: `scale(0.7)`,\n    opacity: 0,\n  },\n  exitAnimation: {\n    top: \"-50%\",\n  },\n  entryAnimation: {\n    top: \"0%\",\n    opacity: 1,\n  },\n\n  flexContainer: {\n    display: \"flex\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    height: \"100%\",\n    position: \"absolute\",\n    width: \"100%\"\n  }\n}\n\nfunction MessageContainer({content, exiting}) {\n  let [ animatorStyles, setStyles ] = useState(styles.base)\n  useEffect(() => {\n    setTimeout(() => \n      setStyles({...styles.base, ...(!exiting ? styles.entryAnimation : styles.exitAnimation ) })\n    , 0)\n  }, [ exiting ])\n\n  return (\n    <div style={styles.flexContainer}>\n      <div style={animatorStyles}>\n        <div style={containerStyle}>\n          {/* {content} */}\n          <MessagesWindow conversation={content}/>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default MessageContainer;\n","import React from 'react';\n\nconst styles = {\n  titleBarContainer:  {\n    position: \"absolute\",\n    width: \"100%\",\n    display: \"flex\",\n    justifyContent: \"center\",\n    \"font-family\": \"Poppins\",\n    fontSize: \"24px\",\n    marginTop: \"20px\",\n    color: \"white\"\n  },\n  titleBar: {\n    background: \"#000000a0\",\n    padding: \"5px 10px\",\n    boxShadow: \"0px 0px 5px 6px #000000a0\",\n    borderRadius: \"10%\",\n    zIndex: 712\n    // width: \"fit-content\"\n  }\n}\n\nfunction TitleBar() {\n  return (\n    <div style={styles.titleBarContainer}>\n      <div style={styles.titleBar}>\n       violet.life\n      </div>\n    </div>\n  )\n}\n\nexport default TitleBar;","import React, { useEffect } from 'react';\nimport MessageContainer from './MessageContainer';\nimport TitleBar from './TitleBar';\n\nconst styles = {\n  wrapper: {\n    height: \"100%\",\n    width: \"100%\"\n  },\n}\n\nlet previousContent = {conversation: null, conversationKey: null}\n\nfunction Wrapper({conversation, conversationKey}) {\n\n  // const [existingContent, setContent] = useState(<div>yo gimme some shit to display</div>)\n  useEffect(() => {\n    previousContent = {conversation, conversationKey}\n  }, [conversation, conversationKey])\n\n  const contentChanged = previousContent.conversation !== null && previousContent.conversation !== conversation // fuck it\n  // console.log(previousContent)\n  // console.log(\"=>\")\n  // console.log(content)\n\n  // console.log(conversationKey)\n  // console.log(previousContent.conversationKey, conversationKey)\n\n  return (\n    <div style={styles.wrapper}>\n      <TitleBar/>\n      {contentChanged ? <MessageContainer key={previousContent.conversationKey} content={previousContent.conversation} exiting={true}/> : null}\n      <MessageContainer key={conversationKey} content={conversation} exiting={false}/>\n    </div>\n  )\n}\n\nexport default Wrapper;\n","import React, { useEffect, useState } from 'react';\nimport Wrapper from './components/Wrapper';\n\nconst style = {\n  width: \"100vw\",\n  height: \"100vh\",\n  \"backgroundColor\": \"skyblue\"\n}\n\nconst pickRandom = array => array[Math.floor(Math.random() * array.length)]\n\nconst conversations = require('./conversations.json');\nlet seenConversations = {}\nconst initialConversation = pickRandom(Object.keys(conversations))\nseenConversations[initialConversation] = true\n\nlet timeout = null;\n\nfunction App() {\n  const [conversationIndex, setConversation] = useState(0)\n  useEffect(() => {\n    timeout = setTimeout(() => {\n        cycleMessage()\n    }, 8000)\n  }, [ conversationIndex ]);\n  \n  const cycleMessage = () => {\n    let unseenConversations = Object.keys(conversations).filter(index => !seenConversations[index])\n    if (unseenConversations.length === 0) {\n      seenConversations = {}\n      unseenConversations = Object.keys(conversations).filter(index => !seenConversations[index]) // this is jank and i choose to not care\n    }\n    const nextConversation = pickRandom(unseenConversations)\n    seenConversations[nextConversation] = true\n    setConversation(nextConversation)\n  }\n\n  const activelyCycleMessage = () => {\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n    cycleMessage()\n  }\n\n  return (\n    <div style={style} onClick={activelyCycleMessage}>\n      <Wrapper conversation={conversations[conversationIndex]} conversationKey={conversationIndex}/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}